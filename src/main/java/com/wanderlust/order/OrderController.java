package com.wanderlust.order;

import com.wanderlust.shared.TripRequest;
import lombok.RequiredArgsConstructor;
import org.springframework.data.redis.core.StringRedisTemplate;
import org.springframework.http.ResponseEntity;
import org.springframework.web.bind.annotation.*;

import java.util.concurrent.TimeUnit;

@RestController
@RequestMapping("/api/order")
@RequiredArgsConstructor
public class OrderController {

    private final StringRedisTemplate redisTemplate;
    private final OrderSaga orderSaga;

    /**
     * EXT: END-TO-END FLOW - STEP 1 (Backend)
     * Receive the Booking Request from the Frontend.
     * 
     * @param key     The unique Idempotency-Key header generated by the frontend.
     * @param request The booking details (flightId, hotelId, etc.).
     */
    @PostMapping("/book")
    public ResponseEntity<?> bookTrip(@RequestHeader("Idempotency-Key") String key, @RequestBody TripRequest request) {
        // FLOW: Validation
        if (key == null || key.trim().isEmpty()) {
            return ResponseEntity.badRequest().body("Idempotency-Key header is required");
        }

        // FLOW: Idempotency Check (Redis)
        // If this key exists, it means we are already processing this click. Block it!
        if (Boolean.TRUE.equals(redisTemplate.hasKey(key))) {
            System.out.println("ðŸ›‘ Duplicate request blocked for key: " + key);
            return ResponseEntity.status(409).body("Already processing this request");
        }

        // Mark as processing for 10 minutes
        redisTemplate.opsForValue().set(key, "PROCESSING", 10, TimeUnit.MINUTES);

        try {
            // FLOW: Trigger the Saga Orchestrator
            System.out.println("ðŸš€ Starting Order Saga for User: " + request.userId());
            orderSaga.bookTrip(request);

            // In a real world scenario, you might update the key to 'COMPLETED' or store
            // the result.
            return ResponseEntity.ok("Booked!");
        } catch (Exception e) {
            // On failure, we might want to allow retries or keep the key to prevent spam.
            // Here we simply re-throw for the Advice to handle or return error.
            redisTemplate.delete(key);
            throw e;
        }
    }
}
